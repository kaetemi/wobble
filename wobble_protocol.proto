syntax = "proto3";

import "nanopb.proto";

enum MessageTypes {
    UNDEFINED = 0;

    // Messages for writing to the server
    OPEN_STREAM = 1;
    WRITE_FRAME = 2;
    CLOSE_STREAM = 3;

    // Messages for streaming from the server
    SUBSCRIBE_STREAM_LIST = 4;
    // UNSUBSCRIBE_STREAM_LIST = 5;
    PUBLISH_STREAM = 6;
    SUBSCRIBE = 7;
    UNSUBSCRIBE = 8;
    PUBLISH_FRAME = 9;

    // Messages for querying older frames from the server
    QUERY_FRAMES = 10;
}

// TODO: Add units and scale to the stream info

message UndefinedMessage {
    MessageTypes message_type = 1;
    // reserve 2 and 3 for future
}

// Stream info
message StreamInfo {
    string name = 4 [(nanopb).max_size = 64]; // internal name
    int32 channels = 7; // 3 for accelerometer
    int32 frequency = 8; // 1100hz for example
    int32 bits = 9; // used bits
    int64 timestamp = 13; // timestamp in microseconds when the stream starts
    int32 timestamp_precision = 22; // 1000000 for precision of +-1s (NTP...)
    double latitude = 23;
    double longitude = 24;

    string description = 14 [(nanopb).max_size = 64]; // display name
    repeated string channel_descriptions = 15 [(nanopb).max_size = 64, (nanopb).max_count = 4]; // but count must match channels value
}

// Open a stream for writing from a sensor
message OpenStream {
    MessageTypes message_type = 1;
    StreamInfo info = 16;
    string password = 5 [(nanopb).max_size = 64];
    int32 alias = 6; // numeric value that will be used for this stream
}

message ChannelData {
    repeated uint32 data = 12 [(nanopb).max_count = 256];
}

// Write a frame to a stream
message WriteFrame {
    MessageTypes message_type = 1;
    int32 alias = 6;
    repeated ChannelData channels = 19 [(nanopb).max_count = 4];
}

// Close a stream
// You should restart a stream anytime the stream timestamp starts drifting off
message CloseStream {
    MessageTypes message_type = 1;
    int32 alias = 6;
}

// List all the streams on this server, and list future streams
// All the streams are public
message SubscribeStreamList {
    MessageTypes message_type = 1;
}

message PublishStream {
    MessageTypes message_type = 1;
    StreamInfo info = 17;
}

// Subscribe to new frames
message Subscribe {
    MessageTypes message_type = 1;
    string name = 4 [(nanopb).max_size = 64]; // internal name
}

// Unsubscribe to new frames
message Unsubscribe {
    MessageTypes message_type = 1;
    string name = 4 [(nanopb).max_size = 64]; // internal name
}

message PublishFrame {
    MessageTypes message_type = 1;
    string name = 4 [(nanopb).max_size = 64]; // internal name
    int64 timestamp = 13; // timestamp for this particular frame in microseconds realtime
    int32 offset = 18; // sample offset in the current series, may reset if the source drops (like timestamp, but counting samples from 0)
    repeated ChannelData channels = 19 [(nanopb).max_count = 4];
}

message QueryFrames {
    MessageTypes message_type = 1;
    string name = 4 [(nanopb).max_size = 64]; // internal name
    int64 from_timestamp = 20; // must be set
    int64 to_timestamp = 21; // if 0, all the way until the latest
}

/* end of file */
